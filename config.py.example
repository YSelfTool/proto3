# (local) database
SQLALCHEMY_DATABASE_URI = "postgresql://user:password@host/database" # change this
#SQLALCHEMY_DATABASE_URI = "mysql://user:password@host/database"
#SQLALCHEMY_DATABASE_URI = "sqlite:///path/to/database.db"
SQLALCHEMY_TRACK_MODIFICATIONS = False # do not change

SECRET_KEY = "something random" # change this

DEBUG = False # do not change

# mailserver (optional)
MAIL_ACTIVE = True
MAIL_FROM = "protokolle@example.com"
MAIL_HOST = "mail.example.com:465"
MAIL_USER = "user" # set to "" for unauthenticated sending
MAIL_PASSWORD = "password" # set to "" for unauthenticated sending
MAIL_USE_TLS = True # should match the port in MAIL_HOST (if present there)
MAIL_USE_STARTTLS = False # Usually, it's either this or SMTPS, not both

# (local) message queue (necessary)
CELERY_BROKER_URL = "redis://localhost:6379/0" # change this if you do not use redis or it is running somewhere else
CELERY_TASK_SERIALIZER = "pickle" # do not change
CELERY_ACCEPT_CONTENT = ["pickle"] # do not change

# CUPS printserver (optional)
PRINTING_ACTIVE = True
PRINTING_SERVER = "printsrv.example.com:631"
PRINTING_USER = "protocols"
PRINTING_PRINTERS = {
    "example_printer": ["Duplex=DuplexNoTumble", "option2=value"],
    "other_printer": ["list", "of", "options"]
}

# etherpad (optional)
ETHERPAD_ACTIVE = True
ETHERPAD_URL = "https://example.com/etherpad" # without /p/â€¦
EMPTY_ETHERPAD = """Welcome to Etherpad!

This pad text is synchronized as you type, so that everyone viewing this page sees the same text. This allows you to collaborate seamlessly on documents!

Get involved with Etherpad at http://etherpad.org

""" # do not change

# wiki (optional)
WIKI_ACTIVE = True
WIKI_TYPE = "MEDIAWIKI"
WIKI_API_URL = "https://wiki.example.com/wiki/api.php"
WIKI_ANONYMOUS = False
WIKI_USER = "user"
WIKI_PASSWORD = "password"
WIKI_DOMAIN = "domain" # set to None if not necessary

# CalDAV calendar (optional)
CALENDAR_ACTIVE = True
CALENDAR_URL = "https://user:password@calendar.example.com/dav/"
CALENDAR_DEFAULT_DURATION = 3 # default meeting length in hours
CALENDAR_MAX_REQUESTS = 10 # number of retries before giving up (some caldav servers like to randomly reply with errors)

SESSION_PROTECTION = "strong" # do not change

# authentication
SECURITY_KEY = "some other random string" # change this
AUTH_MAX_DURATION = 300
from auth import LdapManager, ADManager, StaticUserManager
AUTH_BACKENDS = [
    LdapManager(
        host="ldap.example.com",
        user_dn="uid={},ou=users,dc=example,dc=com",
        group_dn="dc=example,dc=com"),
    ADManager(
        host="ad.example.com",
        domain="EXAMPLE",
        user_dn="cn=users,dc=example,dc=com",
        group_dn="dc=example,dc=com",
        ca_cert="/etc/ssl/certs/example-ca.pem"),
    StaticUserManager(
        users=(
            ("username", "password", ("group1", "group2")),
            ("testuser", "abc123", ("group1",)),
        )
    ),
    PAMManager(),
]

OBSOLETION_WARNING = """Please migrate your account!""" # not important

# lines of error description
ERROR_CONTEXT_LINES = 3

# pagination
PAGE_LENGTH = 20
PAGE_DIFF = 3

# upcoming meetings within this number of days from today are shown on the index page
MAX_INDEX_DAYS = 14
MAX_PAST_INDEX_DAYS = 2
MAX_PAST_INDEX_DAYS_BEFORE_REMINDER = 14

# mail to contact in case of complex errors
ADMIN_MAIL = "admin@example.com"
# users with this group may see and do everything
ADMIN_GROUP = "admin"

# accept protocols even with some errors
# useful for importing old protocols
# not recommended for regular operation
PARSER_LAZY = False

# minimum similarity (0-100) todos need to have to be considered equal while importing
FUZZY_MIN_SCORE = 90

# choose something nice from fc-list
# Nimbus Sans looks very much like Computer Modern
FONTS = {
    "main": {
        "extension": ".otf",
        "path": "/usr/share/fonts/OTF/",
        "regular": "NimbusSans-Regular",
        "bold": "NimbusSans-Bold",
        "italic": "NimbusSans-Oblique",
        "bolditalic": "NimbusSans-BoldOblique"
    },
    "roman": {
        "extension": ".otf",
        "path": "/usr/share/fonts/OTF/",
        "regular": "NimbusRoman-Regular",
        "bold": "NimbusRoman-Bold",
        "italic": "NimbusRoman-Italic",
        "bolditalic": "NimbusRoman-BoldItalic"
    },
    "sans": {
        "extension": ".otf",
        "path": "/usr/share/fonts/OTF/",
        "regular": "NimbusSans-Regular",
        "bold": "NimbusSans-Bold",
        "italic": "NimbusSans-Oblique",
        "bolditalic": "NimbusSans-BoldOblique"
    },
    "mono": {
        "extension": ".otf",
        "path": "/usr/share/fonts/OTF/",
        "regular": "NimbusMonoPS-Regular",
        "bold": "NimbusMonoPS-Bold",
        "italic": "NimbusMonoPS-Italic",
        "bolditalic": "NimbusMonoPS-BoldItalic"
    }
}

# local filesystem path to save compiled and uploaded protocols (and attachments)
DOCUMENTS_PATH = "documents"

# keywords indicating private protocol parts
PRIVATE_KEYWORDS = ["private", "internal", "privat", "intern"]

# list of bulletpoints to use in latex
# these are latex-defaults, add more if you like more
# they are cycled as often as necessary to allow (theoretically) infinite nesting depth
LATEX_BULLETPOINTS = [
    r"\textbullet",
    r"\normalfont \bfseries \textendash",
    r"\textasteriskcentered",
    r"\textperiodcentered"
]

# optional: path to additional jinja-templates
#LATEX_LOCAL_TEMPLATES = "local-templates"
# optional: the template to include at the top of protocol.tex
#LATEX_LOGO_TEMPLATE = "asta-logo.tex"
# optional: custom protocol page geometry
#LATEX_GEOMETRY = "bottom=1.6cm,top=1.6cm,inner=2.5cm,outer=1.0cm,footskip=1.0cm,headsep=0.6cm"
# optional: custom protocol pagestyle
#LATEX_PAGESTYLE = "fancy"
# optional: additional latex packages
#LATEX_ADDITIONAL_PACKAGES = ["[absolute]{textpos}", "{fancyheadings}"]
# optional: include header and footer in asta-style, not just a page number on top
#LATEX_HEADER_FOOTER = True

HTML_LEVEL_OFFSET = 3

def dummy_todomail_provider():
    return {"example": ("Name", "mail@example.com")}

# if you want to generate this mapping automatically
# manually creating todomails through the web interface will still be possible for every authenticated user
# list of functions that return dicts mapping todomail-keys to a tuple containing name and mail address
ADDITIONAL_TODOMAIL_PROVIDERS = [
    dummy_todomail_provider
]
